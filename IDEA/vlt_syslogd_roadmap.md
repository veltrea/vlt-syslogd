# vlt-syslogd: Shift-JIS 救済ロードマップ (vNext)

## 背景と目的
日本国内の運用現場、特に閉鎖網内のレガシーシステムや Windows Server 2012/2016 世代が残る環境では、依然として Shift-JIS (CP932) への根強い信頼（信仰心）が存在します。
現行の `vlt-syslogd` (v0.1.x) は「UTF-8 Only」を掲げることで実装のシンプルさとパフォーマンスを優先しましたが、真に「日本の現場で愛されるツール」になるためには、これらレガシーエンコーディングへの対応が不可欠です。

## 現状の課題
- **一方的な UTF-8 解釈**: 受信したバイト列を `from_utf8_lossy` で一律にデコードしているため、非 UTF-8 バイトはすべて `` (U+FFFD) に破壊されます。
- **事後的な修復不可**: 一度 `String` （UTF-8）に変換されて破壊されたデータは、後から Shift-JIS として再解釈することが不可能です。

### 1. 相互運用性を重視したエンコーディング自動判定 (MSG-ANY 対応)
他の syslog サーバーやレガシーデバイスからのログを受け取る際、必ずしも独自ラベルが期待できるとは限りません。そのため、受信側では「推測」による判定ロジックを主軸に据えます。

- **「関数1個」の威力**: Rust のエコシステム（`chardetng` や `encoding_rs`）を活用すれば、複雑な判定ロジックもライブラリの呼び出し一つで高い精度を実現できます。
- **グローバル対応**: 日本語（Shift-JIS）だけでなく、韓国語や中国語、あるいは壊れた文字コードが送られてくる可能性も想定し、デコード結果を即座に内部表現である UTF-8 に変換して保持します。
- **メリット**: 設定不要で「とりあえず送れば読める」という体験を提供でき、既存システムとの親和性が最大化されます。

### 2. RFC 5424 Structured Data (SD) による明示的な指定（最適化パス）
Suite 同士（`rust-logger` + `vlt-syslogd`）で運用する場合は、さらに確実な「チート法」を併用します。
- **受信レイヤ**: `UdpSocket` から受け取った `[u8]` を即座に `String` に変換せず、SD パースが終わるまで生のバイト列として保持します。
- **ヘッダーパース**: HEADER と STRUCURED-DATA は常に ASCII 範囲内であるため、まずそこをパースして `charset` パラメータを探します。

### 3. エンコーディング検知アルゴリズムの統合
SD による指定がない場合、以下の優先順位でデコーダーを選択するハイブリッド方式を採ります：

1.  **UTF-8 BOM 検知**: `EF BB BF` で始まる場合は UTF-8 強制。
2.  **有効性チェック**: `std::str::from_utf8` でパースを試み、成功すれば UTF-8。
3.  **フォールバック検知**: `encoding_rs` ライブラリ等を用い、日本環境であれば `Shift_JIS` (Windows-31J) とみなしてデコード。
4.  **最終手段**: それでも失敗する場合のみ、損失を許容してデコード。

### 3. 推奨ライブラリの活用
- **`encoding_rs`**: Firefox でも採用されている高速・堅牢な文字コード変換ライブラリ。
- **`chardetng`**: ブラウザレベルの精度でエンコーディングを推定。

### 4. UI/UX への反映
- **検知エンコードの表示**: ログ一覧に「Enc」カラムを追加し、どのエンコードとして解釈されたか（UTF-8, SJIS, ASCII）を可視化します。
- **再解釈機能**: 右クリックメニューから「Shift-JIS で再読み込み」といった手動オーバーライド機能を提供します。

---

## グラちゃんからのアドバイス
> [!TIP]
> 「日本人の心を掴むには、まず『文字化けさせない』ことが最強の営業活動になるよ！今の実装はシンプルでいいけど、次は『どんな汚い（レガシーな）データが来ても優しく受け止める』包容力を身につけようね！」
